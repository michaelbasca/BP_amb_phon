ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/psychopy/data/1_bp_cv_pretest_2015_Jul_21_1338
p8
sS'runtimeInfo'
p9
NsS'name'
p10
Vbp_cv_pretest
p11
sS'dataNames'
p12
(lp13
S'instructionResp.keys'
p14
aS'instructionResp.rt'
p15
aS'trialResp.keys'
p16
aS'trialResp.rt'
p17
asS'autoLog'
p18
I01
sS'extraInfo'
p19
(dp20
S'session'
p21
V001
p22
sS'participant'
p23
V1
sS'frameRate'
p24
cnumpy.core.multiarray
scalar
p25
(cnumpy
dtype
p26
(S'f8'
I0
I1
tRp27
(I3
S'<'
NNNI-1
I-1
I0
tbS'\t\xdb\xc7c\x97\x04N@'
tRp28
sS'list'
p29
V1
sS'expName'
p30
g11
sS'date'
p31
V2015_Jul_21_1338
p32
ssS'loopsUnfinished'
p33
(lp34
g1
(cpsychopy.data
TrialHandler
p35
g3
NtRp36
(dp37
S'origin'
p38
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.82.01), Tue Jul 21 13:38:01 2015\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = u'bp_cv_pretest'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'list':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1280, 800), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "instructions"\u000ainstructionsClock = core.Clock()\u000ainstructionText = visual.TextStim(win=win, ori=0, name='instructionText',\u000a    text=u'These are the instructions',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aleftPhoneme = visual.TextStim(win=win, ori=0, name='leftPhoneme',\u000a    text='default text',    font=u'Arial',\u000a    pos=[-0.5, 0], height=0.2, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000arightPhoneme = visual.TextStim(win=win, ori=0, name='rightPhoneme',\u000a    text='default text',    font=u'Arial',\u000a    pos=[0.5, 0], height=0.2, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000acvSound = sound.Sound('A', secs=-1)\u000acvSound.setVolume(1)\u000a\u000a# Initialize components for Routine "blockBreak"\u000ablockBreakClock = core.Clock()\u000aisBlock = visual.TextStim(win=win, ori=0, name='isBlock',\u000a    text=u'This is block:',    font=u'Arial',\u000a    pos=[0, 0.1], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000ablockText = visual.TextStim(win=win, ori=0, name='blockText',\u000a    text='default text',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apressCont = visual.TextStim(win=win, ori=0, name='pressCont',\u000a    text=u'Press any button to continue',    font=u'Arial',\u000a    pos=[0, -0.1], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000a\u000a# Initialize components for Routine "trial"\u000atrialClock = core.Clock()\u000aleftPhoneme = visual.TextStim(win=win, ori=0, name='leftPhoneme',\u000a    text='default text',    font=u'Arial',\u000a    pos=[-0.5, 0], height=0.2, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000arightPhoneme = visual.TextStim(win=win, ori=0, name='rightPhoneme',\u000a    text='default text',    font=u'Arial',\u000a    pos=[0.5, 0], height=0.2, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000acvSound = sound.Sound('A', secs=-1)\u000acvSound.setVolume(1)\u000a\u000a# Initialize components for Routine "expEnd"\u000aexpEndClock = core.Clock()\u000aendText = visual.TextStim(win=win, ori=0, name='endText',\u000a    text=u'The experiment is now over.\u005cn\u005cnThank you for your participation.\u005cn\u005cnThe experimentor will be with you soon.',    font=u'Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color=u'white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instructions"-------\u000at = 0\u000ainstructionsClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ainstructionResp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ainstructionResp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructionsComponents = []\u000ainstructionsComponents.append(instructionText)\u000ainstructionsComponents.append(instructionResp)\u000afor thisComponent in instructionsComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instructions"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructionsClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instructionText* updates\u000a    if t >= 0.0 and instructionText.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instructionText.tStart = t  # underestimates by a little under one frame\u000a        instructionText.frameNStart = frameN  # exact frame index\u000a        instructionText.setAutoDraw(True)\u000a    \u000a    # *instructionResp* updates\u000a    if t >= 0.0 and instructionResp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instructionResp.tStart = t  # underestimates by a little under one frame\u000a        instructionResp.frameNStart = frameN  # exact frame index\u000a        instructionResp.status = STARTED\u000a        # keyboard checking is just starting\u000a        instructionResp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if instructionResp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['enter', '1', '2'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            instructionResp.keys = theseKeys[-1]  # just the last key pressed\u000a            instructionResp.rt = instructionResp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructionsComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instructions"-------\u000afor thisComponent in instructionsComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif instructionResp.keys in ['', [], None]:  # No response was made\u000a   instructionResp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('instructionResp.keys',instructionResp.keys)\u000aif instructionResp.keys != None:  # we had a response\u000a    thisExp.addData('instructionResp.rt', instructionResp.rt)\u000athisExp.nextEntry()\u000a# the Routine "instructions" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock1 = data.TrialHandler(nReps=1, method='random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'stimConditions.xlsx'),\u000a    seed=None, name='block1')\u000athisExp.addLoop(block1)  # add the loop to the experiment\u000athisBlock1 = block1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock1.rgb)\u000aif thisBlock1 != None:\u000a    for paramName in thisBlock1.keys():\u000a        exec(paramName + '= thisBlock1.' + paramName)\u000a\u000afor thisBlock1 in block1:\u000a    currentLoop = block1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock1.rgb)\u000a    if thisBlock1 != None:\u000a        for paramName in thisBlock1.keys():\u000a            exec(paramName + '= thisBlock1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    leftPhoneme.setText(optionLeft)\u000a    rightPhoneme.setText(optionRight)\u000a    cvSound.setSound(wavFile)\u000a    trialResp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    trialResp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(leftPhoneme)\u000a    trialComponents.append(ISI)\u000a    trialComponents.append(rightPhoneme)\u000a    trialComponents.append(cvSound)\u000a    trialComponents.append(trialResp)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *leftPhoneme* updates\u000a        if t >= 0.5 and leftPhoneme.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftPhoneme.tStart = t  # underestimates by a little under one frame\u000a            leftPhoneme.frameNStart = frameN  # exact frame index\u000a            leftPhoneme.setAutoDraw(True)\u000a        \u000a        # *rightPhoneme* updates\u000a        if t >= 0.5 and rightPhoneme.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightPhoneme.tStart = t  # underestimates by a little under one frame\u000a            rightPhoneme.frameNStart = frameN  # exact frame index\u000a            rightPhoneme.setAutoDraw(True)\u000a        # start/stop cvSound\u000a        if t >= 1 and cvSound.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            cvSound.tStart = t  # underestimates by a little under one frame\u000a            cvSound.frameNStart = frameN  # exact frame index\u000a            cvSound.play()  # start the sound (it finishes automatically)\u000a        \u000a        # *trialResp* updates\u000a        if t >= 1 and trialResp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            trialResp.tStart = t  # underestimates by a little under one frame\u000a            trialResp.frameNStart = frameN  # exact frame index\u000a            trialResp.status = STARTED\u000a            # keyboard checking is just starting\u000a            trialResp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if trialResp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                trialResp.keys = theseKeys[-1]  # just the last key pressed\u000a                trialResp.rt = trialResp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 0.0 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(0.5)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    cvSound.stop() #ensure sound has stopped at end of routine\u000a    # check responses\u000a    if trialResp.keys in ['', [], None]:  # No response was made\u000a       trialResp.keys=None\u000a    # store data for block1 (TrialHandler)\u000a    block1.addData('trialResp.keys',trialResp.keys)\u000a    if trialResp.keys != None:  # we had a response\u000a        block1.addData('trialResp.rt', trialResp.rt)\u000a    # the Routine "trial" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block1'\u000a\u000a\u000a#------Prepare to start Routine "blockBreak"-------\u000at = 0\u000ablockBreakClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000ablockResp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000ablockResp.status = NOT_STARTED\u000a# keep track of which components have finished\u000ablockBreakComponents = []\u000ablockBreakComponents.append(isBlock)\u000ablockBreakComponents.append(blockText)\u000ablockBreakComponents.append(pressCont)\u000ablockBreakComponents.append(blockResp)\u000afor thisComponent in blockBreakComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "blockBreak"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = blockBreakClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *isBlock* updates\u000a    if t >= 0.0 and isBlock.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        isBlock.tStart = t  # underestimates by a little under one frame\u000a        isBlock.frameNStart = frameN  # exact frame index\u000a        isBlock.setAutoDraw(True)\u000a    \u000a    # *blockText* updates\u000a    if t >= 0.0 and blockText.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        blockText.tStart = t  # underestimates by a little under one frame\u000a        blockText.frameNStart = frameN  # exact frame index\u000a        blockText.setAutoDraw(True)\u000a    if blockText.status == STARTED:  # only update if being drawn\u000a        blockText.setText(blockNo, log=False)\u000a    \u000a    # *pressCont* updates\u000a    if t >= 0.0 and pressCont.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        pressCont.tStart = t  # underestimates by a little under one frame\u000a        pressCont.frameNStart = frameN  # exact frame index\u000a        pressCont.setAutoDraw(True)\u000a    \u000a    # *blockResp* updates\u000a    if t >= 0.0 and blockResp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        blockResp.tStart = t  # underestimates by a little under one frame\u000a        blockResp.frameNStart = frameN  # exact frame index\u000a        blockResp.status = STARTED\u000a        # keyboard checking is just starting\u000a        blockResp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if blockResp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['y', 'n', 'left', 'right', 'space', '1', '2'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            blockResp.keys = theseKeys[-1]  # just the last key pressed\u000a            blockResp.rt = blockResp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in blockBreakComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "blockBreak"-------\u000afor thisComponent in blockBreakComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif blockResp.keys in ['', [], None]:  # No response was made\u000a   blockResp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('blockResp.keys',blockResp.keys)\u000aif blockResp.keys != None:  # we had a response\u000a    thisExp.addData('blockResp.rt', blockResp.rt)\u000athisExp.nextEntry()\u000a# the Routine "blockBreak" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a# set up handler to look after randomisation of conditions etc\u000ablock2 = data.TrialHandler(nReps=1, method='random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'stimConditions.xlsx', selection=5),\u000a    seed=None, name='block2')\u000athisExp.addLoop(block2)  # add the loop to the experiment\u000athisBlock2 = block2.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisBlock2.rgb)\u000aif thisBlock2 != None:\u000a    for paramName in thisBlock2.keys():\u000a        exec(paramName + '= thisBlock2.' + paramName)\u000a\u000afor thisBlock2 in block2:\u000a    currentLoop = block2\u000a    # abbreviate parameter names if possible (e.g. rgb = thisBlock2.rgb)\u000a    if thisBlock2 != None:\u000a        for paramName in thisBlock2.keys():\u000a            exec(paramName + '= thisBlock2.' + paramName)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    leftPhoneme.setText(optionLeft)\u000a    rightPhoneme.setText(optionRight)\u000a    cvSound.setSound(wavFile)\u000a    trialResp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    trialResp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(leftPhoneme)\u000a    trialComponents.append(ISI)\u000a    trialComponents.append(rightPhoneme)\u000a    trialComponents.append(cvSound)\u000a    trialComponents.append(trialResp)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *leftPhoneme* updates\u000a        if t >= 0.5 and leftPhoneme.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftPhoneme.tStart = t  # underestimates by a little under one frame\u000a            leftPhoneme.frameNStart = frameN  # exact frame index\u000a            leftPhoneme.setAutoDraw(True)\u000a        \u000a        # *rightPhoneme* updates\u000a        if t >= 0.5 and rightPhoneme.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightPhoneme.tStart = t  # underestimates by a little under one frame\u000a            rightPhoneme.frameNStart = frameN  # exact frame index\u000a            rightPhoneme.setAutoDraw(True)\u000a        # start/stop cvSound\u000a        if t >= 1 and cvSound.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            cvSound.tStart = t  # underestimates by a little under one frame\u000a            cvSound.frameNStart = frameN  # exact frame index\u000a            cvSound.play()  # start the sound (it finishes automatically)\u000a        \u000a        # *trialResp* updates\u000a        if t >= 1 and trialResp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            trialResp.tStart = t  # underestimates by a little under one frame\u000a            trialResp.frameNStart = frameN  # exact frame index\u000a            trialResp.status = STARTED\u000a            # keyboard checking is just starting\u000a            trialResp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if trialResp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['1', '2'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                trialResp.keys = theseKeys[-1]  # just the last key pressed\u000a                trialResp.rt = trialResp.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 0.0 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(0.5)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    cvSound.stop() #ensure sound has stopped at end of routine\u000a    # check responses\u000a    if trialResp.keys in ['', [], None]:  # No response was made\u000a       trialResp.keys=None\u000a    # store data for block2 (TrialHandler)\u000a    block2.addData('trialResp.keys',trialResp.keys)\u000a    if trialResp.keys != None:  # we had a response\u000a        block2.addData('trialResp.rt', trialResp.rt)\u000a    # the Routine "trial" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'block2'\u000a\u000a\u000a#------Prepare to start Routine "expEnd"-------\u000at = 0\u000aexpEndClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000aendResp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000aendResp.status = NOT_STARTED\u000a# keep track of which components have finished\u000aexpEndComponents = []\u000aexpEndComponents.append(endText)\u000aexpEndComponents.append(endResp)\u000afor thisComponent in expEndComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "expEnd"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = expEndClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *endText* updates\u000a    if t >= 0.0 and endText.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        endText.tStart = t  # underestimates by a little under one frame\u000a        endText.frameNStart = frameN  # exact frame index\u000a        endText.setAutoDraw(True)\u000a    \u000a    # *endResp* updates\u000a    if t >= 0.0 and endResp.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        endResp.tStart = t  # underestimates by a little under one frame\u000a        endResp.frameNStart = frameN  # exact frame index\u000a        endResp.status = STARTED\u000a        # keyboard checking is just starting\u000a        endResp.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if endResp.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['q'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            endResp.keys = theseKeys[-1]  # just the last key pressed\u000a            endResp.rt = endResp.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in expEndComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "expEnd"-------\u000afor thisComponent in expEndComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif endResp.keys in ['', [], None]:  # No response was made\u000a   endResp.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('endResp.keys',endResp.keys)\u000aif endResp.keys != None:  # we had a response\u000a    thisExp.addData('endResp.rt', endResp.rt)\u000athisExp.nextEntry()\u000a# the Routine "expEnd" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000awin.close()\u000acore.quit()\u000a
p39
sS'thisTrial'
p40
g1
(cpsychopy.data
TrialType
p41
c__builtin__
dict
p42
(dp43
VoptionRight
p44
VT
sVidx
p45
I8
sVblockNo
p46
I8
sVoptionLeft
p47
VP
sVstimNo
p48
I1
sVcontinuumNo
p49
I8
sVwavFile
p50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/1_pai_tai_8.wav
p51
stRp52
sS'_exp'
p53
I197845136
sg10
S'block1'
p54
sg6
S'/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/psychopy/bp_cv_pretest.py'
p55
sS'thisRepN'
p56
I0
sg18
I01
sg19
g20
sS'data'
p57
g1
(cpsychopy.data
DataHandler
p58
g42
(dp59
S'ran'
p60
cnumpy.ma.core
_mareconstruct
p61
(cnumpy.ma.core
MaskedArray
p62
cnumpy
ndarray
p63
(I0
tp64
S'b'
tRp65
(I1
(I22
I1
tg26
(S'f4'
I0
I1
tRp66
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg16
cnumpy.core.multiarray
_reconstruct
p67
(g63
(I0
tS'b'
tRp68
(I1
(I22
I1
tg26
(S'O4'
I0
I1
tRp69
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp70
S'--'
p71
aS'1'
aS'--'
p72
aS'--'
p73
aS'--'
p74
aS'--'
p75
aS'--'
p76
aS'--'
p77
aS'--'
p78
aS'--'
p79
aS'--'
p80
aS'--'
p81
aS'2'
aS'--'
p82
aS'--'
p83
aS'--'
p84
aS'--'
p85
aS'--'
p86
aS'--'
p87
aS'--'
p88
aS'--'
p89
aS'--'
p90
atbsS'order'
p91
g61
(g62
g63
g64
S'b'
tRp92
(I1
(I22
I1
tg66
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x01\x00\x01\x01\x01\x01\x01\x00\x01\x01\x01\x01\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01'
Ntbsg17
g61
(g62
g63
g64
S'b'
tRp93
(I1
(I22
I1
tg66
I00
S'\x00\x00\x00\x00\x08\xfb2?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x8f\x19?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x01\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01'
NtbstRp94
(dp95
S'isNumeric'
p96
(dp97
g60
I01
sg16
I00
sg91
I01
sg17
I01
ssS'trials'
p98
g36
sS'dataTypes'
p99
(lp100
g60
ag91
ag16
ag17
asS'dataShape'
p101
(lp102
I22
aI1
asbsS'method'
p103
S'random'
p104
sS'sequenceIndices'
p105
g67
(g63
(I0
tS'b'
tRp106
(I1
(I22
I1
tg26
(S'i4'
I0
I1
tRp107
(I3
S'<'
NNNI-1
I-1
I0
tbI01
S'\x01\x00\x00\x00\x0c\x00\x00\x00\x07\x00\x00\x00\x02\x00\x00\x00\x08\x00\x00\x00\x13\x00\x00\x00\x15\x00\x00\x00\t\x00\x00\x00\x00\x00\x00\x00\x12\x00\x00\x00\x05\x00\x00\x00\x04\x00\x00\x00\x14\x00\x00\x00\x10\x00\x00\x00\x11\x00\x00\x00\x0b\x00\x00\x00\x06\x00\x00\x00\x0f\x00\x00\x00\n\x00\x00\x00\x0e\x00\x00\x00\x03\x00\x00\x00\r\x00\x00\x00'
tbsS'finished'
p108
I00
sS'nReps'
p109
I1
sS'nRemaining'
p110
I19
sS'trialList'
p111
(lp112
g1
(g41
g42
(dp113
g44
VT
sg45
I1
sg46
I1
sg47
VP
sg48
I1
sg49
I1
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/1_pai_tai_1.wav
p114
stRp115
ag1
(g41
g42
(dp116
g44
VT
sg45
I2
sg46
I2
sg47
VP
sg48
I1
sg49
I2
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/1_pai_tai_2.wav
p117
stRp118
ag1
(g41
g42
(dp119
g44
VT
sg45
I3
sg46
I3
sg47
VP
sg48
I1
sg49
I3
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/1_pai_tai_3.wav
p120
stRp121
ag1
(g41
g42
(dp122
g44
VT
sg45
I4
sg46
I4
sg47
VP
sg48
I1
sg49
I4
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/1_pai_tai_4.wav
p123
stRp124
ag1
(g41
g42
(dp125
g44
VT
sg45
I5
sg46
I5
sg47
VP
sg48
I1
sg49
I5
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/1_pai_tai_5.wav
p126
stRp127
ag1
(g41
g42
(dp128
g44
VT
sg45
I6
sg46
I6
sg47
VP
sg48
I1
sg49
I6
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/1_pai_tai_6.wav
p129
stRp130
ag1
(g41
g42
(dp131
g44
VT
sg45
I7
sg46
I7
sg47
VP
sg48
I1
sg49
I7
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/1_pai_tai_7.wav
p132
stRp133
ag52
ag1
(g41
g42
(dp134
g44
VT
sg45
I9
sg46
I9
sg47
VP
sg48
I1
sg49
I9
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/1_pai_tai_9.wav
p135
stRp136
ag1
(g41
g42
(dp137
g44
VT
sg45
I10
sg46
I10
sg47
VP
sg48
I1
sg49
I10
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/1_pai_tai_10.wav
p138
stRp139
ag1
(g41
g42
(dp140
g44
VT
sg45
I11
sg46
I11
sg47
VP
sg48
I1
sg49
I11
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/1_pai_tai_11.wav
p141
stRp142
ag1
(g41
g42
(dp143
g44
VP
sg45
I12
sg46
I2
sg47
VT
sg48
I2
sg49
I1
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/2_toh_poh_1.wav
p144
stRp145
ag1
(g41
g42
(dp146
g44
VP
sg45
I13
sg46
I3
sg47
VT
sg48
I2
sg49
I2
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/2_toh_poh_2.wav
p147
stRp148
ag1
(g41
g42
(dp149
g44
VP
sg45
I14
sg46
I4
sg47
VT
sg48
I2
sg49
I3
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/2_toh_poh_3.wav
p150
stRp151
ag1
(g41
g42
(dp152
g44
VP
sg45
I15
sg46
I5
sg47
VT
sg48
I2
sg49
I4
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/2_toh_poh_4.wav
p153
stRp154
ag1
(g41
g42
(dp155
g44
VP
sg45
I16
sg46
I6
sg47
VT
sg48
I2
sg49
I5
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/2_toh_poh_5.wav
p156
stRp157
ag1
(g41
g42
(dp158
g44
VP
sg45
I17
sg46
I7
sg47
VT
sg48
I2
sg49
I6
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/2_toh_poh_6.wav
p159
stRp160
ag1
(g41
g42
(dp161
g44
VP
sg45
I18
sg46
I8
sg47
VT
sg48
I2
sg49
I7
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/2_toh_poh_7.wav
p162
stRp163
ag1
(g41
g42
(dp164
g44
VP
sg45
I19
sg46
I9
sg47
VT
sg48
I2
sg49
I8
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/2_toh_poh_8.wav
p165
stRp166
ag1
(g41
g42
(dp167
g44
VP
sg45
I20
sg46
I10
sg47
VT
sg48
I2
sg49
I9
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/2_toh_poh_9.wav
p168
stRp169
ag1
(g41
g42
(dp170
g44
VP
sg45
I21
sg46
I11
sg47
VT
sg48
I2
sg49
I10
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/2_toh_poh_10.wav
p171
stRp172
ag1
(g41
g42
(dp173
g44
VP
sg45
I22
sg46
I1
sg47
VT
sg48
I2
sg49
I11
sg50
V/Users/lauragwilliams/Documents/experiments/b_p/BP_amb_phon/pre_tests/CV_categorisation/experiment_files/stimuli_wav/2_toh_poh_11.wav
p174
stRp175
asS'seed'
p176
NsS'thisIndex'
p177
g25
(g107
S'\x07\x00\x00\x00'
tRp178
sS'thisN'
p179
I2
sS'thisTrialN'
p180
I2
sS'nTotal'
p181
I22
sS'_warnUseOfNext'
p182
I01
sbasS'saveWideText'
p183
I01
sS'thisEntry'
p184
(dp185
sS'version'
p186
S''
sS'_paramNamesSoFar'
p187
(lp188
g44
ag47
ag46
ag45
ag48
ag49
ag50
asS'entries'
p189
(lp190
(dp191
g30
g11
sg23
V1
sg14
S'1'
sg24
g28
sg29
V1
sg21
g22
sg31
g32
sg15
F0.5777430534362793
sa(dp192
g30
g11
sS'block1.thisRepN'
p193
I0
sg45
I2
sS'block1.thisN'
p194
I0
sg29
V1
sS'block1.thisIndex'
p195
g25
(g107
S'\x01\x00\x00\x00'
tRp196
sg24
g28
sg44
VT
sS'block1.thisTrialN'
p197
I0
sg16
S'1'
sg21
g22
sg46
I2
sg47
VP
sg31
g32
sg48
I1
sg23
V1
sg49
I2
sg17
F0.6991429328918457
sg50
g117
sa(dp198
g30
g11
sS'block1.thisRepN'
p199
I0
sg45
I13
sS'block1.thisN'
p200
I1
sg29
V1
sS'block1.thisIndex'
p201
g25
(g107
S'\x0c\x00\x00\x00'
tRp202
sg24
g28
sg44
VP
sS'block1.thisTrialN'
p203
I1
sg16
S'2'
sg21
g22
sg46
I3
sg47
VT
sg31
g32
sg48
I2
sg23
V1
sg49
I2
sg17
F0.59984803199768066
sg50
g147
sasS'loops'
p204
(lp205
g36
asS'savePickle'
p206
I00
sb.